(defun split-first (char string)
  (let ((pos (position char string)))
    (if pos
        (subseq string 0 pos)
        string)))

(defun read-error (fin)
  (let ((line (read-line fin)))
    (when (string= line "Statistics:")
      (return-from read-error nil))
    (labels ((read-value (line &optional (discard 0))
               (with-input-from-string (in line)
                 (loop :repeat discard :do (read in))
                 (split-first #\,
                              (string-left-trim '(#\Space)
                                                (read-line in)))))
             (rlrv (n)
               (read-value (read-line fin) n)))
      (list :url (read-value line 1)
            :name (rlrv 1)
            :parent (rlrv 2)
            :real (rlrv 2)
            :error (progn (read-line fin) (rlrv 1))))))

(defun read-errors (fin &key error-recovery-p)
  (if error-recovery-p
      (handler-case (loop :until (string= (read-line fin) ""))
        (end-of-file () (return-from read-errors '())))
      (read-line fin))
  (let ((err (handler-case (read-error fin)
               (end-of-file () 'continue))))
    (cond
      ((eql err 'continue)
       (read-errors fin :error-recovery-p t))
      ((and (listp err) (not (null err)))
       (cons err (read-errors fin)))
      (t
       '()))))

(defun group (key list &key (test #'eql))
  (let ((h (make-hash-table :test test)))
    (flet ((add (x)
             (push x (gethash (funcall key x) h))))
      (mapc #'add list))
    (let ((l '()))
      (maphash (lambda (k v)
                 (push (cons k v) l))
               h)
      l)))

(defun plist-p (list)
  (or (null list)
      (and (not (null (rest list)))
           (keywordp (first list))
           (plist-p (cddr list)))))

(deftype plist () '(and list (satisfies plist-p)))

(defun lisp->json (obj &optional (out t))
  (etypecase obj
    (null (format out "null"))
    ((or number string) (write obj :stream out))
    ((or symbol keyword) (lisp->json (symbol-name obj) out))
    (plist
     (format out "{")
     (labels ((write-plist (plist)
                (lisp->json (first plist) out)
                (format out ":")
                (lisp->json (second plist) out)
                (when (cddr plist)
                  (format out ",")
                  (write-plist (cddr plist)))))
       (write-plist obj))
     (format out "}"))
    (list
     (format out "[")
     (labels ((write-array (arr)
                (lisp->json (first arr) out)
                (when (rest arr)
                  (format out ",")
                  (write-array (rest arr)))))
       (write-array obj))
     (format out "]"))))


(defun errs->json (list)
  (let* ((grouped (group (lambda (x) (getf x :parent))
                         list
                         :test 'equalp))
         (as-plist-arr (mapcar (lambda (group)
                                 (list :parent (first group)
                                       :errors (rest group)))
                               grouped)))
    (lisp->json as-plist-arr *standard-output*)
    (length as-plist-arr)))

(defun link2json (file)
  (with-open-file (fin file :direction :input)
    (loop :repeat 10 :do (read-line fin)) ; throw away the intro
    (let* ((errs (read-errors fin))
           (errsf (errs->json errs))
           (log (list :errors (length errs)
                      :files-with-errors errsf)))
      (format *terminal-io* "~A~%" log)
      log)))

(defun main ()
  (let ((file (nth 1 *posix-argv*)))
    (link2json file)))
